name: Create VPS

on:
  workflow_dispatch:
  repository_dispatch:
    types: [create-vps]

jobs:
  start-vps:
    runs-on: ubuntu-latest
    timeout-minutes: 355   # run slightly under 6 hours

    env:
      # Hardcoded Discord webhook (per your request)
      DISCORD_WEBHOOK: "https://discord.com/api/webhooks/1354349049410490418/XaRlJspNCk8h8QMkY329QVqNOP2BiJ-hx_1MA00EDSNDXFDJxwPAbjReNuKeGfweTA7X"

    steps:
      - name: â¬‡ï¸ Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“‚ Prepare workspace
        run: |
          mkdir -p links .backup temp || true
          chmod 777 links .backup temp || true

      - name: ğŸ§° Install helper tools (no docker apt install)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y unzip jq curl git || true
          # only install tmate if missing
          if ! command -v tmate >/dev/null 2>&1; then
            sudo apt-get install -y tmate || true
          fi
          # docker is usually preinstalled on runners; if missing, try convenience script
          if ! command -v docker >/dev/null 2>&1; then
            curl -fsSL https://get.docker.com | sh
          fi
          docker --version || true

      - name: Set Laravel APP_KEY
  run: |
    APP_KEY="base64:0nYbJe1iR9o0bLJYy7exKgDq+Zoy7Z9Wm8rKpW63g2k="
    echo "APP_KEY=$APP_KEY" >> .env


      - name: ğŸ•¸ Create docker network
        run: |
          docker network create pteronet || true

      - name: ğŸ›¢ Start MySQL in Docker
        run: |
          # run MySQL (use mysql:8) with native auth set by image args
          docker rm -f pterodactyl_mysql || true
          docker run -d --name pterodactyl_mysql \
            --network pteronet \
            -e MYSQL_ROOT_PASSWORD=rootpass \
            -e MYSQL_DATABASE=pterodactyl_db \
            -e MYSQL_USER=ptero \
            -e MYSQL_PASSWORD=pteropass \
            mysql:8.0 --default-authentication-plugin=mysql_native_password

          echo "Waiting for MySQL to become ready..."
          for i in $(seq 1 30); do
            docker exec pterodactyl_mysql mysql -uroot -prootpass -e "SELECT 1;" >/dev/null 2>&1 && break
            sleep 2
          done
          docker exec pterodactyl_mysql mysql -uroot -prootpass -e "SHOW DATABASES;" || (docker logs pterodactyl_mysql && exit 1)

      - name: ğŸ”§ Start Pterodactyl Panel container (with fixed APP_KEY)
        env:
          APP_KEY: ${{ secrets.APP_KEY }}
        run: |
          docker rm -f pterodactyl || true
          docker volume create pterodactyl_panel_data || true

          docker run -d --name pterodactyl \
            --network pteronet \
            -p 8080:80 \
            -e DB_HOST=pterodactyl_mysql \
            -e DB_PORT=3306 \
            -e DB_DATABASE=pterodactyl_db \
            -e DB_USERNAME=ptero \
            -e DB_PASSWORD=pteropass \
            -e APP_KEY="$APP_KEY" \
            -v pterodactyl_panel_data:/var/www/pterodactyl \
            ghcr.io/pterodactyl/panel:latest

          echo "Waiting for panel container to accept artisan commands..."
          for i in $(seq 1 30); do
            docker exec pterodactyl php -v >/dev/null 2>&1 && break
            sleep 3
          done

      - name: âš™ï¸ Run migrations (retry until ready)
        run: |
          set -e
          # attempt migrations inside the panel container
          for i in $(seq 1 20); do
            docker exec pterodactyl php artisan migrate --force && break || {
              echo "artisan migrate failed, retrying in 10s ($i/20)..."
              sleep 10
            }
          done

      - name: ğŸ‘‘ Ensure admin user exists (same account across runs)
        run: |
          set -e
          ADMIN_EMAIL="admin@example.com"
          ADMIN_PASS="AdminPass123"
          # create admin user (artisan will error if user exists â€” that's okay)
          docker exec -i pterodactyl php artisan p:user:make \
            --email="$ADMIN_EMAIL" \
            --username="admin" \
            --name-first="Auto" \
            --name-last="Admin" \
            --password="$ADMIN_PASS" \
            --admin=1 || true
          # save admin info to links for convenience
          echo "EMAIL:$ADMIN_EMAIL" > links/admin_info.txt
          echo "PASS:$ADMIN_PASS" >> links/admin_info.txt

      - name: ğŸ‰ Write minimal Wings config & Start Wings container
        run: |
          # create a simple wings config pointing to the panel container on docker network
          cat > temp/wings.yml <<'EOF'
panel:
  url: "http://pterodactyl"
  token_id: "localtoken"
  token: "localtoken123"
  verify_tls: false
api:
  host: 0.0.0.0
  port: 8080
docker:
  network:
    interface: docker0
EOF
          # persist the wings config into backup later
          docker rm -f pterodactyl_wings || true
          docker run -d --name pterodactyl_wings \
            --privileged \
            --network pteronet \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v /etc/pterodactyl:/etc/pterodactyl:rw \
            -v /var/lib/pterodactyl:/var/lib/pterodactyl:rw \
            -v $PWD/temp/wings.yml:/etc/pterodactyl/config.yml \
            ghcr.io/pterodactyl/wings:latest || true
          # give wings a few seconds to start
          sleep 8
          docker logs pterodactyl_wings --tail 50 || true
          # attempt to start any existing containers (best-effort)
          docker ps -a -q | xargs -r docker start || true

      - name: ğŸŒ Install & start ngrok (tunnel panel port)
        run: |
          cd $GITHUB_WORKSPACE/temp
          curl -s -L "https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip" -o ngrok.zip
          unzip -o ngrok.zip >/dev/null 2>&1 || true
          chmod +x ngrok || true
          nohup ./ngrok http 8080 >/dev/null 2>&1 &
          sleep 6
          # get ngrok public url
          PANEL_URL=$(curl -s http://127.0.0.1:4040/api/tunnels | jq -r '.tunnels[0].public_url' || echo "")
          if [ -z "$PANEL_URL" ] || [ "$PANEL_URL" == "null" ]; then
            # fallback to instance public IP (may not always be reachable)
            PANEL_URL="http://$(curl -s ifconfig.me | tr -d '\n'):8080"
          fi
          echo "$PANEL_URL" | tee links/panel_url.txt

- name: ğŸ”Œ Start tmate session and capture SSH
  run: |
    # ensure tmate present (installed earlier)
    if ! command -v tmate >/dev/null 2>&1; then
      sudo apt-get update && sudo apt-get install -y tmate
    fi

    VPS_NAME="${GITHUB_EVENT_CLIENT_PAYLOAD_VPS_NAME:-autovps}"

    tmate -S /tmp/tmate.sock new-session -d
    tmate -S /tmp/tmate.sock wait tmate-ready
    SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}')
    echo "$SSH" | tee "links/${VPS_NAME}.txt"
    echo "SSH:$SSH" >> links/admin_info.txt || true

      - name: ğŸ’¾ Dump MySQL DB (backup)
        run: |
          mkdir -p .backup
          docker exec pterodactyl_mysql sh -c 'exec mysqldump -uptero -ppteropass pterodactyl_db' > .backup/pterodactyl.sql || true
          # save wings config into backup
          cp temp/wings.yml .backup/wings.yml || true

      - name: ğŸ’¾ Save panel files (best-effort)
        run: |
          # attempt to archive panel path from the container (best-effort)
          rm -f .backup/panel_files.tar.gz || true
          docker exec pterodactyl sh -c "tar -czf /tmp/panel_files.tar.gz /var/www/pterodactyl 2>/dev/null || true" || true
          docker cp pterodactyl:/tmp/panel_files.tar.gz .backup/panel_files.tar.gz 2>/dev/null || true

      - name: ğŸ’¼ Pack all backups
        run: |
          NAME="${{ github.event.client_payload.vps_name }}"
          if [ -z "$NAME" ]; then NAME="autovps"; fi
          zip -r ".backup/${NAME}.zip" .backup/* links/* 2>/dev/null || true

      - name: ğŸ›  Prepare Git (sync remote to avoid non-fast-forward)
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch origin main || true
          git checkout main || true
          git pull --rebase origin main || true

      - name: â¬†ï¸ Commit & Push backups
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ğŸ”„ Updated SSH, Panel URL, admin info, and backups for ${{ github.event.client_payload.vps_name || 'autovps' }}"
          file_pattern: 'links/*.txt .backup/*.zip .backup/*.sql .backup/*.yml'
          commit_user_name: "github-actions[bot]"
          commit_user_email: "41898282+github-actions[bot]@users.noreply.github.com"
          push_options: '--force-with-lease'

      - name: ğŸ“© Discord Notify (Panel URL, Admin, SSH)
        run: |
          PANEL_URL=$(cat links/panel_url.txt || echo "unavailable")
          SSH_URL=$(cat "links/${{ github.event.client_payload.vps_name || 'autovps' }}.txt" || echo "unavailable")
          ADMIN_INFO=$(cat links/admin_info.txt || echo "admin@example.com / AdminPass123")
          # Build message with jq to keep JSON safe
          CONTENT="ğŸ–¥ï¸ **Pterodactyl Panel Ready!**\n\nğŸŒ URL: ${PANEL_URL}\nğŸ‘¤ Admin: ${ADMIN_INFO}\n\nğŸ”— SSH: ${SSH_URL}\n\nâš¡ Link rotates every ~6h."
          JSON=$(jq -n --arg content "$CONTENT" '{content: $content}')
          curl -H "Content-Type: application/json" -X POST -d "$JSON" "$DISCORD_WEBHOOK" || true

      - name: ğŸ” Schedule re-dispatch (auto-restart) & keep alive
        env:
          REPO: ${{ github.repository }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # schedule re-dispatch in background (~340 minutes)
          PAYLOAD=$(jq -n --arg n "autovps" '{event_type: "create-vps", client_payload: { vps_name: $n, backup: true }}')
          (
            sleep $((340*60))
            curl -s -X POST "https://api.github.com/repos/$REPO/dispatches" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: token $TOKEN" \
              -d "$PAYLOAD" || true
          ) &
          echo "Runner will stay alive for 355 minutes (keep session until re-dispatch)."
          sleep $((355*60))
